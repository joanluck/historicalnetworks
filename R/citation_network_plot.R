#' citation_network_plot
#'
#' \code{citation_network_plot} generates plots of citation networks, depicting works as dots ("nodes", in network parlance) and citations as arrows ("edges") from cited works to citing works.
#' 
#' @param citations A dataframe representing classified citations such as that generated by \code{\link[classify_citations()]{classify_citations}}.
#' @param cited_only A dataframe representing the works that are only cited by---not citing---the other works in \code{citations}.  This need only be specified if multiple classifications are employed (e.g., "agree" and "disagree") and not all of the only-cited works fall into the first classification.  Otherwise, this information will be automatically generated from \code{citations}.
#' @param color_plot Should multiple classifications be denoted by different colors?  If not, they will indicated by different shapes.
#' @param custom_plot Should the function return a bare plot suitable for customization using \code{\link[ggnetwork]{ggnetwork}} functions?
#' @param arrow_gap A parameter that will shorten the arrows that link works in order to avoid overplotting the dots that represent the works; larger values may be desirable if \code{custom_plot} is set to TRUE and the size of the dots will be increased using \code{\link[ggnetwork]{ggnetwork}}'s \code{\link[geom_nodes]{geom_nodes}} function.
#' 
#' @details
#' The `citation_network_plot` function 
#' 
#' @return A ggplot object
#'
#' @examples
#' 
#' @importFrom dplyr "%>%" select mutate filter bind_rows
#' @importFrom stringr str_extract
#' @importFrom network network "%v%<-" get.vertex.attribute
#' @importFrom sna as.sociomatrix.sna symmetrize
#' @importFrom purrr map_dbl
#' @import ggnetwork
#' @import ggplot2
#'
#' @export

citation_network_plot <- function(citations, cited_only, color_plot = TRUE, custom_plot = FALSE, arrow_gap = .015) {
    if (missing(cited_only)) {
        cited_only <- data_frame(citing = citations$cited[!citations$cited %in% citations$citing]) %>% 
            mutate(year = str_extract(citing, "\\d{4}") %>% 
                       as.numeric(),
                   classification = 1) %>% 
            distinct()
    }
    
    if (!("citing" %in% names(citations))) {
        citations <- citations %>% 
        mutate(citing_author = if_else(str_detect(author, ","), 
                                       str_replace(author, "(^[^,]*).*", "\\1"),
                                       author),
               citing = paste(citing_author, date)) %>% 
            select(cited, citing, date, classification)
    } 
    
    if (!("classification" %in% names(citations))) {
        citations$classification <- 1
    }
    
    cited_works <- citations %>% 
        group_by(citing) %>% 
        summarize(classification = max(classification),
                  year = as.numeric(min(date))) %>% 
        ungroup() %>% 
        bind_rows(cited_only) %>% 
        arrange(citing)

    cite_net <- network(citations, matrix.type = "edgelist")
    cite_net %v% "year" <- cited_works$year
    cite_net %v% "classification" <- cited_works$classification
    
    layout <- plot.layout.cite(cite_net)

    cite_network <- ggnetwork::ggnetwork(cite_net, layout = as.matrix(layout), arrow.gap = arrow_gap)
    
    cite_network$x <- cite_network$x[,1]
    cite_network$y <- cite_network$y[,1]
    cite_network$xend <- cite_network$xend[,1]
    cite_network$yend <- cite_network$yend[,1]
    
    if (!custom_plot) {
        if (color_plot) {
            network_plot <- ggplot(cite_network,
                                   aes(x, y, xend = xend, yend = yend)) +
                geom_edges(color = "grey85",
                           arrow = arrow(length = unit(5, "pt")),
                           curvature = 0.05) +
                geom_nodes(size = 6, aes(color = as.factor(cite_network$classification))) +
                geom_nodetext(aes(label = vertex.names)) +
                theme_blank() + 
                scale_color_manual(values = c("1" = "grey75", "2" = "red")) +
                theme(legend.position="none")
        } else {
            network_plot <- ggplot(cite_network,
                                   aes(x, y, xend = xend, yend = yend)) +
                geom_edges(color = "grey85",
                           arrow = arrow(length = unit(5, "pt")),
                           curvature = 0.05) +
                geom_nodes(size = 6, aes(shape = as.factor(cite_network$classification))) +
                geom_nodetext(aes(label = vertex.names)) +
                theme_blank() + 
                scale_shape_manual(values = c(16, 21)) +
                theme(legend.position="none")
        }
    } else {
        network_plot <- ggplot(cite_network,
                               aes(x, y, xend = xend, yend = yend))
    }
    
    return(network_plot)  
}


plot.layout.cite <- function(d, seed = 324, trials = 100, root_source) {
    set.seed(seed)
    
    if (!missing(root_source)) {
        root <- which(unlist(lapply(d$val, `[`, c('vertex.names')))==root_source)
    }
    
    d_mat <- sna::as.sociomatrix.sna(d)
    if (is.list(d_mat)) {
        d_mat <- d_mat[[1]]
    }
    
    n <- nrow(d_mat)
    y_real <- get.vertex.attribute(d, "year")
    y <- get.vertex.attribute(d, "year") %>% jitter(amount = 1)
    y_range <- max(y) - min(y)
    n_y <- data_frame(y = y) %>%
        group_by(y) %>% 
        mutate(n_y = n()) %>% 
        ungroup() %>% 
        last()
    old_crit <- 0
    
    for (i in 1:trials) {
        a_dx <- rep(0, n)
        r_dx <- rep(0, n)
        x <- purrr::map_dbl(n_y, function(x) {
            seq(from = -y_range, to = y_range, length.out = x + 5) %>% 
                sample(size = 1) %>% 
                jitter(amount = y_range/20)
        })
        if (!missing(root_source)) {
            x[root] <- 0 
        }
        x_old <- x
        
        ds <- sna::symmetrize(d_mat, "weak")
        dis <- as.matrix(dist(cbind(x, y)))
        
        for (j in 1:25) {
            x_old <- x
            theta <- acos(t(outer(x, x, "-"))/dis) * sign(t(outer(y, y, "-")))
            
            # horizontal attraction between nodes with ties
            a_dx <- apply(ds * cos(theta) * dis/10, 
                          1, sum, na.rm = TRUE)
            
            x <- (x + a_dx) %>% 
                pmin(., y_range) %>% 
                pmax(., -y_range)
            dis <- as.matrix(dist(cbind(x, y)))
            theta <- acos(t(outer(x, x, "-"))/dis) * sign(t(outer(y, y, "-")))
            
            # vertical attraction between nodes and actual years
            y <- (y_real + y)/2
            
            # repulsion between close nodes
            r_dx <- apply(cos(theta) * y_range^2/(2*dis^2), 
                          1, sum, na.rm = TRUE)
            r_dy <- apply(sin(theta) * y_range/dis^2, 
                          1, sum, na.rm = TRUE) %>% 
                pmin(., y_range/100) %>% 
                pmax(., -y_range/100)
            
            x <- x - r_dx 
            y <- y - r_dy
            
            if (!missing(root_source)) {
                x[root] <- mean(x)
            }
            dis <- as.matrix(dist(cbind(x, y)))
        }
        
        crit <- min(dis[dis!=0])
        if (crit > old_crit) {
            old_crit <- crit
            pos <- cbind(x, y)
        }
    }
    pos <- as_data_frame(pos)
    return(pos)
}


