#' citation_network_plot
#'
#' \code{citation_network_plot} does stuff 
#' 
#' @param citations A dataframe representing classified citations such as that generated by \code{\link[classify_citations()]{classify_citations}}.
#' @param cited_only A dataframe representing the works that are only cited by---not citing---the other works in \code{citations}.  This need only be specified if multiple classifications are employed (e.g., "agree" and "disagree") and not all of the only-cited works fall into the first classification.  Otherwise, this information will be automatically generated from \code{citations}.
#' @param ... Optional further parameters to pass along to \code{\link[GGally::ggnet2]{ggnet2}}.
#' 
#' @details
#' The `citation_network_plot` function 
#' 
#' @return A ggplot object
#'
#' @examples
#' 
#' @importFrom dplyr "%>%" select mutate filter bind_rows
#' @importFrom stringr str_extract
#' @importFrom network network "%v%" get.vertex.attribute
#' @importFrom sna as.sociomatrix.sna
#' @importFrom purrr map_dbl
#' @importFrom GGally ggnet2
#'
#' @export

citation_network_plot <- function(citations, cited_only, ...) {
    if (missing(cited_only)) {
        cited_only <- data_frame(citing = citations$cited[!citations$cited %in% citations$citing]) %>% 
            mutate(year = str_extract(citing, "\\d{4}") %>% 
                       as.numeric(),
                   classification = 1) %>% 
            distinct()
    }

    
    if (!("citing" %in% names(citations))) {
        citations <- citations %>% 
        mutate(citing_author = if_else(str_detect(author, ","), 
                                       str_replace(author, "(^[^,]*).*", "\\1"),
                                       author),
               citing = paste(citing_author, date)) %>% 
            select(cited, citing, date, classification)
    } 
    
    if (!("classification" %in% names(citations))) {
        citations$classification <- 1
    }
    
    cited_works <- citations %>% 
        group_by(citing) %>% 
        summarize(classification = max(classification),
                  year = as.numeric(min(date))) %>% 
        ungroup() %>% 
        bind_rows(cited_only) %>% 
        arrange(citing)

    cite_net <- network(citations, matrix.type = "edgelist")
    cite_net %v% "year" <- cited_works$year
    cite_net %v% "classification" <- cited_works$classification
    
    layout <- plot.layout.cite(cite_net)

    cite_net %v% "x" = layout$x
    cite_net %v% "y" = get.vertex.attribute(cite_net, "year")

    
    plot_defaults <- list(label = TRUE, 
                          label.size = 3,
                          node.alpha = .6, 
                          node.size = 4,
                          arrow.size = 5, 
                          arrow.gap = .01,
                          palette = c("1" = "grey80", "2" = "red"))
    plot_args <- modifyList(plot_defaults, list(...))
    plot_args <- modifyList(plot_args, list(net = cite_net, mode = c("x", "y"), node.color = "classification"))
    
    network_plot <- do.call(GGally::ggnet2, plot_args)  
}


plot.layout.cite <- function(d, seed = 324, trials = 100, root_source="") {
    set.seed(seed)
    
    if (!missing(root_source)) {
        root <- which(unlist(lapply(d$val, `[`, c('vertex.names')))==root_source)
    }
    
    d_mat <- sna::as.sociomatrix.sna(d)
    if (is.list(d_mat)) {
        d_mat <- d_mat[[1]]
    }
    
    n <- nrow(d_mat)
    y_real <- get.vertex.attribute(d, "year")
    y <- get.vertex.attribute(d, "year") %>% jitter(amount = 1)
    y_range <- max(y) - min(y)
    n_y <- data_frame(y = y) %>%
        group_by(y) %>% 
        mutate(n_y = n()) %>% 
        ungroup() %>% 
        last()
    old_crit <- 0
    
    for (i in 1:trials) {
        a_dx <- rep(0, n)
        r_dx <- rep(0, n)
        x <- purrr::map_dbl(n_y, function(x) {
            seq(from = -y_range, to = y_range, length.out = x + 5) %>% 
                sample(size = 1) %>% 
                jitter(amount = y_range/20)
        })
        x[root] <- 0
        x_old <- x
        
        ds <- symmetrize(d_mat, "weak")
        dis <- as.matrix(dist(cbind(x, y)))
        
        for (j in 1:25) {
            x_old <- x
            theta <- acos(t(outer(x, x, "-"))/dis) * sign(t(outer(y, y, "-")))
            
            # horizontal attraction between nodes with ties
            a_dx <- apply(ds * cos(theta) * dis/10, 
                          1, sum, na.rm = TRUE)
            
            x <- (x + a_dx) %>% 
                pmin(., y_range) %>% 
                pmax(., -y_range)
            dis <- as.matrix(dist(cbind(x, y)))
            theta <- acos(t(outer(x, x, "-"))/dis) * sign(t(outer(y, y, "-")))
            
            # vertical attraction between nodes and actual years
            y <- (y_real + y)/2
            
            # repulsion between close nodes
            r_dx <- apply(cos(theta) * y_range^2/(2*dis^2), 
                          1, sum, na.rm = TRUE)
            r_dy <- apply(sin(theta) * y_range/dis^2, 
                          1, sum, na.rm = TRUE) %>% 
                pmin(., y_range/100) %>% 
                pmax(., -y_range/100)
            
            x <- x - r_dx 
            y <- y - r_dy
            
            x[root] <- mean(x)
            dis <- as.matrix(dist(cbind(x, y)))
        }
        
        crit <- min(dis[dis!=0])
        if (crit > old_crit) {
            old_crit <- crit
            pos <- cbind(x, y)
        }
    }
    pos <- as_data_frame(pos)
    return(pos)
}


